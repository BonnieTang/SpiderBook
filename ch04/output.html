<html><title>Python爬虫开发与项目实战</title><meta charset="UTF-8"><body><table align='center' border=1 rules='all' cellpadding='15'><tr bgcolor='# ccc'><th> 标题 </th><th> 链接 </th><th> 概要 </th></tr><tr align='center'><td>'NoneType' object is not iterable</td><td> <a href="http://www.cnblogs.com/themost/p/7521149.html"> http://www.cnblogs.com/themost/p/7521149.html </a></td><td>摘要: "TypeError: 'NoneType' object is not iterable" 一般是返回值为None同时赋值给了多个变量阅读全文</td></tr><tr align='center'><td>url的解码方式</td><td> <a href="http://www.cnblogs.com/themost/p/7484308.html"> http://www.cnblogs.com/themost/p/7484308.html </a></td><td>摘要: #coding:utf-8 import urllib legal_person_string = "%E6%B3%95%E5%AE%9A%E4%BB%A3%E8%A1%A8%E4%BA%BA" legal_person_string = legal_person_string.decode("gbk").encode('utf-8') legal_person_caption = urllib...阅读全文</td></tr><tr align='center'><td>[转]获取当前执行主脚本的方法</td><td> <a href="http://www.cnblogs.com/themost/p/7467238.html"> http://www.cnblogs.com/themost/p/7467238.html </a></td><td>摘要: python __file__ 与argv[0] 在python下，获取当前执行主脚本的方法有两个：sys.argv[0]和__file__。 sys.argv[0] 获取主执行文件路径的最佳方法是用sys.argv[0]，它可能是一个相对路径，所以再取一下abspath是保险的做法，像这样： import os,sys dirname, filename = os.path.split(o...阅读全文</td></tr><tr align='center'><td>字典的update方法</td><td> <a href="http://www.cnblogs.com/themost/p/7364154.html"> http://www.cnblogs.com/themost/p/7364154.html </a></td><td>摘要: 1 >>> dict = {"name":"zara", "age": 7} 2 >>> dict2 = {"sex":"female"} 3 >>> dict.update(dict2) 4 >>> dict 5 {'name': 'zara', 'age': 7, 'sex': 'female'}阅读全文</td></tr><tr align='center'><td>单元测试</td><td> <a href="http://www.cnblogs.com/themost/p/7255730.html"> http://www.cnblogs.com/themost/p/7255730.html </a></td><td>摘要: # 单元测试 如果你听说过“测试驱动开发”（TDD:Test-Driven Development），单元测试就不陌生。 单元测试是用来对一个模块、一盒函数或者一个类来进行正确性检验的测试工作。 比如对函数abs（），我们可以编写出以下几个测试用例： 1、输入整数，比如1、1.2、0.99，期待返回值与输入相同； 2、输入负数，比如-1、-1.2、-0.99，期待返回值与是呼入相反； 3、输...阅读全文</td></tr><tr align='center'><td>python的调试</td><td> <a href="http://www.cnblogs.com/themost/p/7246723.html"> http://www.cnblogs.com/themost/p/7246723.html </a></td><td>摘要: 调试 程序能一次写完并正常执行的概率很小。总会有各种各样的bug需要修正。 有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时 哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。 第一种方法：print 简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看： def foo(s): n = int(s) ...阅读全文</td></tr><tr align='center'><td>python的错误处理</td><td> <a href="http://www.cnblogs.com/themost/p/7245014.html"> http://www.cnblogs.com/themost/p/7245014.html </a></td><td>摘要: 一、python的错误处理 在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错以及出错的原因。 在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数open()，成功时返回文件的描述符（就是一个整数），出错时返回-1 用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须大量的代码来判断是否出错： d...阅读全文</td></tr><tr align='center'><td>错误、调试和测试是怎样的</td><td> <a href="http://www.cnblogs.com/themost/p/7243643.html"> http://www.cnblogs.com/themost/p/7243643.html </a></td><td>摘要: 在程序运行过程中，总会遇到各种各样的错误。有的错误是程序编写有问题造成的，比如本来应该输出整数，输出了字符串，这种错误我们称为bug，bug是必须修复的。有的错误是用户输入造成的，比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理。还有一类错误是无法在程序阅读全文</td></tr><tr align='center'><td>python如何转换word格式、读取word内容、转成html</td><td> <a href="http://www.cnblogs.com/themost/p/7243511.html"> http://www.cnblogs.com/themost/p/7243511.html </a></td><td>摘要: # python如何转换word格式、读取word内容、转成html？ import docx from win32com import client as wc # 首先将doc转换成docx word = wc.Dispatch("Word.Application") doc = word.Documents.Open(r"D:\\demo.doc") #使用参数16表示将doc转换成...阅读全文</td></tr><tr align='center'><td>函数的参数详解</td><td> <a href="http://www.cnblogs.com/themost/p/7242970.html"> http://www.cnblogs.com/themost/p/7242970.html </a></td><td>摘要: # 函数的参数 定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就算完成了。 对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了 函数内政部的复杂逻辑被封装起来，调用者无需了解。 python的函数定义非常简单，单灵活度却非常大。除了正常定义的必选参数外， 还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数 还...阅读全文</td></tr><tr align='center'><td>用函数装饰一首诗</td><td> <a href="http://www.cnblogs.com/themost/p/7222152.html"> http://www.cnblogs.com/themost/p/7222152.html </a></td><td>摘要: # -*- coding: UTF-8 -*- # 层层嵌套，像谜语 # 函数装饰器用途非常广泛，在许多包里随处可见 # 一直不太会用，决心重点研究一下 # 模块化思维的前提： # 实现一个功能有很多步骤，我们尽可能不一蹴而就，而是分模块开发 # 既然要层层分解，写函数的时候，最好就不要让单一的函数过于复杂 # 一个函数仅实现一个小功能，只返回一个结果为上佳 # 对函数装饰器的理解： # 函...阅读全文</td></tr><tr align='center'><td>python手动设置递归调用深度</td><td> <a href="http://www.cnblogs.com/themost/p/7210381.html"> http://www.cnblogs.com/themost/p/7210381.html </a></td><td>摘要: python超出递归深度时会出现异常： RuntimeError: maximum recursion depth exceeded python默认的递归深度是很有限的，大概是900当递归深度超过这个值的时候，就会引发这样的一个异常。 解决的方式是手工设置递归调用深度，方式为阅读全文</td></tr><tr align='center'><td>[转]时间与时间戳之间的转换</td><td> <a href="http://www.cnblogs.com/themost/p/7096848.html"> http://www.cnblogs.com/themost/p/7096848.html </a></td><td>摘要: 文章来源:http://blog.csdn.net/google19890102/article/details/51355282 对于时间数据，如2016-05-05 20:28:54，有时需要与时间戳进行相互的运算，此时就需要对两种形式进行转换，在Python中，转换时需要用到time模块，具体阅读全文</td></tr><tr align='center'><td>dict的update方法</td><td> <a href="http://www.cnblogs.com/themost/p/7056609.html"> http://www.cnblogs.com/themost/p/7056609.html </a></td><td>摘要: dict = {'Name': 'Zara', 'Age': 7} dict2 = {'Sex': 'female' } dict.update(dict2)输出结果:{'Age': 7, 'Name': 'Zara', 'Sex': 'female'}阅读全文</td></tr><tr align='center'><td>类和对象概念理解</td><td> <a href="http://www.cnblogs.com/themost/p/7050210.html"> http://www.cnblogs.com/themost/p/7050210.html </a></td><td>摘要: 类和对象对象即是模拟真实世界,把数据和代码封装在一起.对象 = 属性 + 方法属性即变量,方法即函数我们把静态的特征成为属性,把动态的特征成为方法. 面向对象编程面向对象编程封装:信息隐蔽技术继承:子类共享父类的属性和方法多态:不同实例对象对同一名称的方法可能响应不同的特征阅读全文</td></tr><tr align='center'><td>super函数的作用</td><td> <a href="http://www.cnblogs.com/themost/p/7050207.html"> http://www.cnblogs.com/themost/p/7050207.html </a></td><td>摘要: super函数的作用super().__init__()当子类重写父类的方法时,会覆盖父类方法,super此举是保留父类 如果属性名跟方法名相同,属性会覆盖方法 方法必须要有实例才能被调用,这叫做绑定阅读全文</td></tr><tr align='center'><td>删除字符串空格方法</td><td> <a href="http://www.cnblogs.com/themost/p/7049291.html"> http://www.cnblogs.com/themost/p/7049291.html </a></td><td>摘要: " abc ".strip() # returns "abc" " xyz ".lstrip() # returns "xyz " " xyz ".rstrip() # returns " xyz" " x y z ".replace(' ', '') # returns "xyz"...阅读全文</td></tr><tr align='center'><td>常见的错误类型和继承关系</td><td> <a href="http://www.cnblogs.com/themost/p/6821416.html"> http://www.cnblogs.com/themost/p/6821416.html </a></td><td>摘要: 1 BaseException 2 +-- SystemExit 3 +-- KeyboardInterrupt 4 +-- GeneratorExit 5 +-- Exception 6 +-- StopIteration 7 +-- StopAsyncIteration 8 +-- ArithmeticError 9 ...阅读全文</td></tr><tr align='center'><td>with工作原理</td><td> <a href="http://www.cnblogs.com/themost/p/6821354.html"> http://www.cnblogs.com/themost/p/6821354.html </a></td><td>摘要: 进入时，调用对象的__enter__ 退出时，调用对象的__exit__阅读全文</td></tr><tr align='center'><td>logging格式</td><td> <a href="http://www.cnblogs.com/themost/p/6821298.html"> http://www.cnblogs.com/themost/p/6821298.html </a></td><td>摘要: 1 import logging 2 3 def foo(s): 4 return 10 / int(s) 5 6 def bar(s): 7 return foo(s) * 2 8 9 def main(): 10 try: 11 bar(0) 12 except Exception as e: 13 ...阅读全文</td></tr><tr align='center'><td>sys.exc_info()可以捕获到任意异常</td><td> <a href="http://www.cnblogs.com/themost/p/6821040.html"> http://www.cnblogs.com/themost/p/6821040.html </a></td><td>摘要: 1 import sys 2 try: 3 a = 3 4 assert a > 4 5 except: 6 exc = sys.exc_info()#返回异常的元祖 7 print (exc)阅读全文</td></tr><tr align='center'><td>异常判断语法</td><td> <a href="http://www.cnblogs.com/themost/p/6818741.html"> http://www.cnblogs.com/themost/p/6818741.html </a></td><td>摘要: 1 try: 2 '主逻辑代码。框住了你感觉会抛出异常的代码' 3 4 except: 5 'try代码块里面如果抛出一场了，该执行这里的内容' 6 7 else: 8 'try代码块入锅没有抛出异常，就执行这里的内容' 9 10 finally: 11 '不管怎么样，这里的代码总会被执行'阅读全文</td></tr><tr align='center'><td>hasattr(obj,attr)  判断前面是否有后面的属性</td><td> <a href="http://www.cnblogs.com/themost/p/6810515.html"> http://www.cnblogs.com/themost/p/6810515.html </a></td><td>摘要: hasattr(obj,attr) 判断前面是否有后面的属性阅读全文</td></tr><tr align='center'><td>isinstance(obj1,class) 可以判断前者是否是后者的实例</td><td> <a href="http://www.cnblogs.com/themost/p/6810503.html"> http://www.cnblogs.com/themost/p/6810503.html </a></td><td>摘要: isinstance(obj1,class) 可以判断前者是否是后者的实例阅读全文</td></tr><tr align='center'><td>issubclass判断前面是不是后面的子类</td><td> <a href="http://www.cnblogs.com/themost/p/6810496.html"> http://www.cnblogs.com/themost/p/6810496.html </a></td><td>摘要: issubclass(sub,sup) 判断前面是不是后面的子类阅读全文</td></tr><tr align='center'><td>子类继承父类后想要扩展父类方法</td><td> <a href="http://www.cnblogs.com/themost/p/6810477.html"> http://www.cnblogs.com/themost/p/6810477.html </a></td><td>摘要: 1 >>> class PClass(object): 2 def setInfo(self,sex='Male'): 3 self.gender = sex 4 5 6 >>> class CClass(PClass): 7 def setInfo(self,who): 8 self.name = who 9...阅读全文</td></tr><tr align='center'><td>__dict__</td><td> <a href="http://www.cnblogs.com/themost/p/6810133.html"> http://www.cnblogs.com/themost/p/6810133.html </a></td><td>摘要: 类有一个__dict__字典属性，保存了当前类的每一个成员，举例如下：阅读全文</td></tr><tr align='center'><td>函数的设计规范</td><td> <a href="http://www.cnblogs.com/themost/p/6807789.html"> http://www.cnblogs.com/themost/p/6807789.html </a></td><td>摘要: 耦合性： 1、尽量通过参数接收输入，以及通过return产生输出以保证函数的独立性 2、尽量减少使用全局变量进行函数间通信 3、不要在函数中改变可变类型的参数 4、避免直接改变定义在另一个模块中的变量 聚合性： 1、每个函数目标是唯一的 2、每隔函数尽量简单阅读全文</td></tr><tr align='center'><td>装饰器</td><td> <a href="http://www.cnblogs.com/themost/p/6807596.html"> http://www.cnblogs.com/themost/p/6807596.html </a></td><td>摘要: 定义：装饰器本身就是一个函数，用于装饰其他函数。 功能：增强被装饰函数的功能。 装饰器一般接收一个函数作为参数，以实现功能增强阅读全文</td></tr><tr align='center'><td>*分解函数参数</td><td> <a href="http://www.cnblogs.com/themost/p/6806802.html"> http://www.cnblogs.com/themost/p/6806802.html </a></td><td>摘要: 调用同事，传入*是为了分解，定义时传入*是为了整合 定义时传入的＊输出时是元祖。阅读全文</td></tr><tr align='center'><td>判断字符串的后缀.endswith()</td><td> <a href="http://www.cnblogs.com/themost/p/6800196.html"> http://www.cnblogs.com/themost/p/6800196.html </a></td><td>摘要: 可以用str.endswith('.jpg')来判断字符串是否以jpg结尾，返回True或者False阅读全文</td></tr><tr align='center'><td>enumerate给列表加索引</td><td> <a href="http://www.cnblogs.com/themost/p/6789544.html"> http://www.cnblogs.com/themost/p/6789544.html </a></td><td>摘要: 1 >>> list = ['a','b','c'] 2 >>> for i,j in enumerate(list): 3 print(i,j) 4 5 6 0 a 7 1 b 8 2 c 9 >>>阅读全文</td></tr><tr align='center'><td>如何判断一个对象是可迭代对象</td><td> <a href="http://www.cnblogs.com/themost/p/6789534.html"> http://www.cnblogs.com/themost/p/6789534.html </a></td><td>摘要: 方法是通过collections模块的iterable类型来判断。阅读全文</td></tr><tr align='center'><td>函数的参数</td><td> <a href="http://www.cnblogs.com/themost/p/6789026.html"> http://www.cnblogs.com/themost/p/6789026.html </a></td><td>摘要: 定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。 小结 Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。阅读全文</td></tr><tr align='center'><td>对%的转义</td><td> <a href="http://www.cnblogs.com/themost/p/6786115.html"> http://www.cnblogs.com/themost/p/6786115.html </a></td><td>摘要: 1 >>> print('growth rate: %d %%'% 7) 2 growth rate: 7 % #百分号对百分号的转义阅读全文</td></tr><tr align='center'><td>ord()与char()</td><td> <a href="http://www.cnblogs.com/themost/p/6786093.html"> http://www.cnblogs.com/themost/p/6786093.html </a></td><td>摘要: >>> ord('王')#获取字符编码 29579 >>> chr(29579)#把编码转成对应的字符 '王'阅读全文</td></tr><tr align='center'><td>［转］map函数补充</td><td> <a href="http://www.cnblogs.com/themost/p/6773977.html"> http://www.cnblogs.com/themost/p/6773977.html </a></td><td>摘要: 来源：http://www.cnblogs.com/superxuezhazha/p/5714970.html阅读全文</td></tr><tr align='center'><td>处理异常的两种写法</td><td> <a href="http://www.cnblogs.com/themost/p/6752596.html"> http://www.cnblogs.com/themost/p/6752596.html </a></td><td>摘要: 1 from urllib.request import Request, urlopen 2 from urllib.error import URLError, HTTPError 3 req = Request(someurl) 4 try: 5 response = urlopen(req) 6 except HTTPError as e: 7 print(...阅读全文</td></tr><tr align='center'><td>urlopen()&urlretrieve()</td><td> <a href="http://www.cnblogs.com/themost/p/6748892.html"> http://www.cnblogs.com/themost/p/6748892.html </a></td><td>摘要: 1、urlopen()方法 urllib.request.urlopen(url[,data[,proxies]]) 创建一个表示远程url的类文件对象，然后像本地文件一样的操作这个类文件对象来获取远程数据 参数url表示远程数据的路径，一般是指网址 参数data表示以post方式提交到url的数据阅读全文</td></tr><tr align='center'><td>join()的用法</td><td> <a href="http://www.cnblogs.com/themost/p/6701806.html"> http://www.cnblogs.com/themost/p/6701806.html </a></td><td>摘要: Python中有join()和os.path.join()两个函数，具体作用如下： join()： 连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串 os.path.join()： 将多个路径组合后返回 一、函数说明1、join()函数 语法： 'sep'.j阅读全文</td></tr><tr align='center'><td>解析器解析全过程</td><td> <a href="http://www.cnblogs.com/themost/p/6662399.html"> http://www.cnblogs.com/themost/p/6662399.html </a></td><td>摘要: 首先，我们先让大家看一下python解析器的全流程： 我们编辑器编写好源代码－>保存成文件。如果源代码中有编码声明而且用的编辑器支持该语法，那么该文件就以相应的编码方式保存在磁盘中。 注意：编码声明和源文件的编码不一定是一致的，你完全可以在编码声明中声明编码为utf-8,但是用GB2312来保存源文阅读全文</td></tr><tr align='center'><td>模拟登陆</td><td> <a href="http://www.cnblogs.com/themost/p/6654541.html"> http://www.cnblogs.com/themost/p/6654541.html </a></td><td>摘要: 模拟登陆的理解：接口层直接操作的模拟登陆，本质上与UI层登录是相同的，都是把需要验证的数据，提交给服务器对应的函数作验证。所以我们要做的就是把人工post的数据，使用代码提交。 模拟的前提首先需要找到登录接口，可以在登录的时候输入错误的账号密码，找到对应的API。 然后抓包看post了哪些数据，一般阅读全文</td></tr><tr align='center'><td>cookielib和urllib2模块结合模拟网站登录</td><td> <a href="http://www.cnblogs.com/themost/p/6640828.html"> http://www.cnblogs.com/themost/p/6640828.html </a></td><td>摘要: 1.cookielib模块 cookielib模块的主要作用就是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问internet资源，例如可以利用本模块的cookiejar类的对象来捕获cookie并在后续链接请求时重新发送。cookielib模块用到的对象主要由cookiej阅读全文</td></tr><tr align='center'><td>下载一只猫</td><td> <a href="http://www.cnblogs.com/themost/p/6637969.html"> http://www.cnblogs.com/themost/p/6637969.html </a></td><td>摘要: 1 import easygui as g 2 import urllib.request 3 4 title = '下载一只猫' 5 msg = '请输入猫的尺寸' 6 values = ('宽','高') 7 8 interface = g.multenterbox(msg,title,values) 9 size = interface[0]+'/'+interfac...阅读全文</td></tr><tr align='center'><td>写一个翻译小工具</td><td> <a href="http://www.cnblogs.com/themost/p/6629100.html"> http://www.cnblogs.com/themost/p/6629100.html </a></td><td>摘要: 1 #写一个翻译小工具 2 3 import urllib.request 4 import urllib.parse 5 import json 6 content = input('请输入要翻译的内容：') 7 8 url = 'http://fanyi.youdao.com/translate?smartresult=\ 9 dict&smartresult=rule...阅读全文</td></tr><tr align='center'><td>copy&deepcopy</td><td> <a href="http://www.cnblogs.com/themost/p/6592610.html"> http://www.cnblogs.com/themost/p/6592610.html </a></td><td>摘要: 1 >>> import copy 2 >>> list1 = [1,2,3,['a','b']] 3 >>> list2 = copy.copy(list1)#浅复制，修改子对象将受影响 4 >>> list3= copy.deepcopy(list1)#深复制，修改子对象不受影响 5 >>> list2 6 [1, 2, 3, ['a', 'b']] 7 >>> list3 ...阅读全文</td></tr><tr align='center'><td>if__name__ == '__main__'</td><td> <a href="http://www.cnblogs.com/themost/p/6576262.html"> http://www.cnblogs.com/themost/p/6576262.html </a></td><td>摘要: 首先，执行b.py。程序执行b.py就需要创建新的模块对象b，然后再执行b.py对应的字节码。 b.py第一行代码为导入a模块，因此程序会导入a模块，同时就要创建模块对象a 然后a.py又执行第一行代码，即导入b模块，此时，因为第一步的时候b模块对象已经创建，所以不再继续创建模块对象，这里进一步往下阅读全文</td></tr><tr align='center'><td>__name__属性</td><td> <a href="http://www.cnblogs.com/themost/p/6575376.html"> http://www.cnblogs.com/themost/p/6575376.html </a></td><td>摘要: 所有的模块都有一个 __name__属性，__name__的值取决于如何应用模块 在作为独立程序运行，或者主程序时，__name__的值是__main__ 而在其他模块中导入了该模块，__name__则为该模块的名字阅读全文</td></tr><tr align='center'><td>模块导入方法汇总</td><td> <a href="http://www.cnblogs.com/themost/p/6563657.html"> http://www.cnblogs.com/themost/p/6563657.html </a></td><td>摘要: 1 #TemperatureConversion 2 3 def c2f(cel): 4 fah = cel * 1.8 + 32 5 return fah 6 7 def f2c(fah): 8 cel = (fah - 32) / 1.8 9 return cel 10 11 #cals 12 13 import Temper...阅读全文</td></tr><tr align='center'><td>生成器以及yield语句</td><td> <a href="http://www.cnblogs.com/themost/p/6557696.html"> http://www.cnblogs.com/themost/p/6557696.html </a></td><td>摘要: 生成器以及yield语句最初的引入是为了让程序员可以更简单的编写用来产生值的序列的代码。 以前，要实现类似随机数生成器的东西，需要实现一个类或者一个模块，在生成数据的同时 保持对每次调用之间状态的跟踪，引入生成器之后，这变得非常简单。 python之外，最简单的生成器应该是被称为协程（corouti阅读全文</td></tr><tr align='center'><td>python判断素数的方法</td><td> <a href="http://www.cnblogs.com/themost/p/6552198.html"> http://www.cnblogs.com/themost/p/6552198.html </a></td><td>摘要: 1 #运用python的数学函数 2 3 import math 4 5 def isPrime(n): 6 if n n: 28 return True 29 if n % i == 0: 30 return False 31 32 ...阅读全文</td></tr><tr align='center'><td>各种推导式</td><td> <a href="http://www.cnblogs.com/themost/p/6546581.html"> http://www.cnblogs.com/themost/p/6546581.html </a></td><td>摘要: 1 列表推导式： 2 3 >>> a = [i for i in range(10) if i % 2 == 0] 4 >>> a 5 [0, 2, 4, 6, 8] 6 7 字典推导式： 8 9 >>> b = {i:i % 2 == 0 for i in range(10)} 10 >>> b 11 {0: True, 1: False, 2: True, 3: Fa...阅读全文</td></tr><tr align='center'><td>迭代器求迄今为止所有的闰年</td><td> <a href="http://www.cnblogs.com/themost/p/6545237.html"> http://www.cnblogs.com/themost/p/6545237.html </a></td><td>摘要: 1 #写一个迭代器，要求输出迄今为止所有的闰年 2 import datetime as dt 3 4 class LeapYear: 5 def __init__(self): 6 self.this_year = dt.date.today().year 7 8 9 def isLeapYear(self,year): 10 ...阅读全文</td></tr><tr align='center'><td>记录列表中每个元素被访问的次数</td><td> <a href="http://www.cnblogs.com/themost/p/6536529.html"> http://www.cnblogs.com/themost/p/6536529.html </a></td><td>摘要: •如果说你希望定制的容器是不可变的话，你只需要定义__len__()和__getitem__()方法。 •如果你希望定制的容器是可变的话，除了__len__()和__getitem__()方法，你还需要定义__setitem__()和__delitem__()两个方法。 •如果说你希望定制的容器是不阅读全文</td></tr><tr align='center'><td>访问修改属性日志</td><td> <a href="http://www.cnblogs.com/themost/p/6528848.html"> http://www.cnblogs.com/themost/p/6528848.html </a></td><td>摘要: 1 import time as t 2 3 class Record: 4 def __init__(self,value= None,name = None): 5 self.value = value 6 self.name = name 7 8 def __get__(self,instance,owner): 9 ...阅读全文</td></tr><tr align='center'><td>描述符</td><td> <a href="http://www.cnblogs.com/themost/p/6523423.html"> http://www.cnblogs.com/themost/p/6523423.html </a></td><td>摘要: 描述符就是将某种特殊类型的类的实例指派给另一个类的属性。 __get__(self, instance, owner) –用于访问属性，它返回属性的值 __set__(self, instance, value) –将在属性分配操作中调用，不返回任何内容 __delete__(self, insta阅读全文</td></tr><tr align='center'><td>摄氏与华氏转变</td><td> <a href="http://www.cnblogs.com/themost/p/6517730.html"> http://www.cnblogs.com/themost/p/6517730.html </a></td><td>摘要: 1 #定义摄氏度的一个类 2 class Celsius: 3 def __init__(self,value = 26.0):#初始化温度为26.0 4 self.value = float(value) #将温度转化为浮点数 5 6 def __get__(self,instance,owner):#定义获取摄氏温度的方法 7 ...阅读全文</td></tr><tr align='center'><td>菜鸟容易中的招__setattr__</td><td> <a href="http://www.cnblogs.com/themost/p/6506942.html"> http://www.cnblogs.com/themost/p/6506942.html </a></td><td>摘要: class Counter: def __init__(self): self.counter = 0 # 这里会触发 __setattr__ 调用 def __setattr__(self, name, value): self.counter += 1 “””既然需要 __setattr__ 调用...阅读全文</td></tr><tr align='center'><td>魔法方法：属性访问</td><td> <a href="http://www.cnblogs.com/themost/p/6505230.html"> http://www.cnblogs.com/themost/p/6505230.html </a></td><td>摘要: __getattr__(self,name) 当用户试图访问name，而name属性不存在时就会调用getattr __getattribute__(self,name) 当用户试图访问name时就会调用getattribute __setattr__(self,name,value)当name被设阅读全文</td></tr><tr align='center'><td>计时器源码</td><td> <a href="http://www.cnblogs.com/themost/p/6486798.html"> http://www.cnblogs.com/themost/p/6486798.html </a></td><td>摘要: 1 import time as t 2 3 class Mytimer: 4 5 def __init__(self): 6 self.prompt = '未开始计时' 7 self.unit = ['年','月','日','时','分','秒'] 8 self.begin = 0 9 self.en...阅读全文</td></tr><tr align='center'><td>常见算数运算符对应的魔法方法</td><td> <a href="http://www.cnblogs.com/themost/p/6445886.html"> http://www.cnblogs.com/themost/p/6445886.html </a></td><td></td></tr><tr align='center'><td>__new__方法首先调用并返回一个实例化对象</td><td> <a href="http://www.cnblogs.com/themost/p/6443689.html"> http://www.cnblogs.com/themost/p/6443689.html </a></td><td>摘要: __new__方法首先调用并返回一个实例化对象阅读全文</td></tr><tr align='center'><td>property()函数</td><td> <a href="http://www.cnblogs.com/themost/p/6443008.html"> http://www.cnblogs.com/themost/p/6443008.html </a></td><td>摘要: 1 class C: 2 def __init__(self, size=10): 3 self.size = size 4 5 def getXSize(self): 6 return self.size 7 8 def setXSize(self, value): 9 self.size = val...阅读全文</td></tr><tr align='center'><td>类相关的BIF</td><td> <a href="http://www.cnblogs.com/themost/p/6442977.html"> http://www.cnblogs.com/themost/p/6442977.html </a></td><td>摘要: 1.>>> issubclass(C,A)＃判断c是A的子类，返回真假 2.>>> isinstance(b1,B) ＃判断c1是B类的实例化对象，返回真假 3.>>> hasattr(c1,‘x’)＃判断实例化对象c1是否拥有x属性，注意x要用引号，返回真假 4.>>> getattr(c1,'y阅读全文</td></tr><tr align='center'><td>__init__特殊方法</td><td> <a href="http://www.cnblogs.com/themost/p/6441346.html"> http://www.cnblogs.com/themost/p/6441346.html </a></td><td>摘要: __init__特殊方法不应当返回除了none以外的任何方法。阅读全文</td></tr><tr align='center'><td>类对象可直接访问属性，但未实例化不能调用方法</td><td> <a href="http://www.cnblogs.com/themost/p/6421952.html"> http://www.cnblogs.com/themost/p/6421952.html </a></td><td>摘要: 我们常说的类指的是类定义，由于python无处不对象，所以当类定义之后，自然就成为一个类对象，在这个时候，你可以对类的属性（变量）进行直接访问，如上面的MyClass.name一个类可以实例化出无数的对象（实例对象），python为了区分是哪个实例对象调用了方法，于是要求方法必须绑定（通过self参阅读全文</td></tr><tr align='center'><td>打开文件修改并存储</td><td> <a href="http://www.cnblogs.com/themost/p/6416639.html"> http://www.cnblogs.com/themost/p/6416639.html </a></td><td>摘要: 1 import easygui as g 2 import os 3 4 5 file_path = g.fileopenbox(default='F:\\') 6 with open(file_path) as f: 7 title = '内容显示' 8 file_name = os.path.basename(file_path) 9 msg...阅读全文</td></tr><tr align='center'><td>python常用的一些东西——sys、os等(转)</td><td> <a href="http://www.cnblogs.com/themost/p/6412637.html"> http://www.cnblogs.com/themost/p/6412637.html </a></td><td>摘要: 1.常用内置函数：(不用import就可以直接使用) help(obj) 在线帮助, obj可是任何类型 callable(obj) 查看一个obj是不是可以像函数一样调用 repr(obj) 得到obj的表示字符串，可以利用这个字符串eval重建该对象的一个拷贝 eval_r(str) 表示合法的阅读全文</td></tr><tr align='center'><td>with语句</td><td> <a href="http://www.cnblogs.com/themost/p/6408214.html"> http://www.cnblogs.com/themost/p/6408214.html </a></td><td>摘要: 使用with语句可以处理多个项目用 ‘，’隔开，例如 with A() as a: with B() as b: suite 可以写成： with A() as a, B() as b: suite阅读全文</td></tr><tr align='center'><td>else语句的搭配</td><td> <a href="http://www.cnblogs.com/themost/p/6407923.html"> http://www.cnblogs.com/themost/p/6407923.html </a></td><td>摘要: 1、else语句搭配if 要么怎样，要么怎样 2、else语句搭配for和while 干完循环之后执行else，干不完或者break就不执行 3、else与异常处理 没有问题的话就执行else吧阅读全文</td></tr><tr align='center'><td>break跳出循环的妙用</td><td> <a href="http://www.cnblogs.com/themost/p/6404143.html"> http://www.cnblogs.com/themost/p/6404143.html </a></td><td>摘要: while True: temp = input('请输入一个整数：') try: temp = int(temp)#这里如果不是整数的话会引发报错，直接进入 except后面的reason，如果是整数则会执行break,跳出循环 break except ValueError as reason:阅读全文</td></tr><tr align='center'><td>sort()与sorted()区分开</td><td> <a href="http://www.cnblogs.com/themost/p/6399961.html"> http://www.cnblogs.com/themost/p/6399961.html </a></td><td>摘要: 列表的排序方法是sort 可用list.sort() sorted()是BIF不能用list.sorted() 引发的异常AttributeError: 'list' object has no attribute 'sorted'阅读全文</td></tr><tr align='center'><td>python常见异常</td><td> <a href="http://www.cnblogs.com/themost/p/6399944.html"> http://www.cnblogs.com/themost/p/6399944.html </a></td><td></td></tr><tr align='center'><td>泡菜的使用pickle</td><td> <a href="http://www.cnblogs.com/themost/p/6396088.html"> http://www.cnblogs.com/themost/p/6396088.html </a></td><td>摘要: 如何实现对列表和字典的写入? 需要将对象流式化，实现对象持久存储，这里用到的事pickle 一、制作泡菜 >>> list1 = ['我',123,3.14,['aaa',1]] #将此列表制作成泡菜>>> import pickle #引入pickle模块>>> pickle_file = ope阅读全文</td></tr><tr align='center'><td>查找目录下的关键字以及显示行数</td><td> <a href="http://www.cnblogs.com/themost/p/6395535.html"> http://www.cnblogs.com/themost/p/6395535.html </a></td><td>摘要: 1 import os 2 def print_pos(key_dict): 3 keys = key_dict.keys() 4 keys = sorted(keys) # 由于字典是无序的，我们这里对行数进行排序 5 for each_key in keys: 6 print('关键字出现在第 %s 行，第 %s 个位置。' % (each...阅读全文</td></tr><tr align='center'><td>find()用法</td><td> <a href="http://www.cnblogs.com/themost/p/6392394.html"> http://www.cnblogs.com/themost/p/6392394.html </a></td><td>摘要: >>> str = '编程改变世界'>>> str.find('编')0>>> str.find('程')1>>> str.find('让')-1 find查找，找到返回第几个位置，默认从0开始 找不到返回-1 原型：find(a,b,c) a是要查找的字符串 b是起始位置，是一个数字 c是结束位置阅读全文</td></tr><tr align='center'><td>查找目录下的文件</td><td> <a href="http://www.cnblogs.com/themost/p/6391659.html"> http://www.cnblogs.com/themost/p/6391659.html </a></td><td>摘要: 1 import os 2 def check_file(start_dir, target): 3 os.chdir(start_dir) 4 for each_file in os.listdir(os.curdir): 5 if each_file == target: 6 print(os.path.join(os.g...阅读全文</td></tr><tr align='center'><td>编程统计制定路径的文件格式</td><td> <a href="http://www.cnblogs.com/themost/p/6390274.html"> http://www.cnblogs.com/themost/p/6390274.html </a></td><td>摘要: 方法一： 方法二：阅读全文</td></tr><tr align='center'><td>编程实现全部替换</td><td> <a href="http://www.cnblogs.com/themost/p/6390025.html"> http://www.cnblogs.com/themost/p/6390025.html </a></td><td>摘要: 1 #编程实现全部替换 2 file_name = input('请输入文件名:') 3 aim_word = input('请输入需要替换的单词或者字符:') 4 new_word = input('请输入新的单词或者字符:') 5 count = 0 6 f = open(file_name) 7 content = [] 8 9 for each_line in f: ...阅读全文</td></tr><tr align='center'><td>编程读取文件指定行</td><td> <a href="http://www.cnblogs.com/themost/p/6389239.html"> http://www.cnblogs.com/themost/p/6389239.html </a></td><td>摘要: 1 #编写程序实现读取文件前几行 2 def print_line(file_name): 3 line = int(input('请输入要显示前几行：')) 4 f = open(file_name) 5 for each_line in range(0,line): 6 print(f.readline()) 7 8 file_name = inpu...阅读全文</td></tr><tr align='center'><td>编写程序比较两个文件的不同</td><td> <a href="http://www.cnblogs.com/themost/p/6389192.html"> http://www.cnblogs.com/themost/p/6389192.html </a></td><td>摘要: 以下是封装成函数：阅读全文</td></tr><tr align='center'><td>接收用户的输入并保存为新的文件</td><td> <a href="http://www.cnblogs.com/themost/p/6388328.html"> http://www.cnblogs.com/themost/p/6388328.html </a></td><td>摘要: 1 #编写一个程序，接收用户的输入并保存为新的文件，程序实现如图 2 def write_poem(file_name): 3 print("请输入内容【单独输入'：w'保存退出】:",end = '') 4 enter_content = input() 5 f = open('F:\\'+file_name,'w') 6 while True: ...阅读全文</td></tr><tr align='center'><td>将文件分对话拆分</td><td> <a href="http://www.cnblogs.com/themost/p/6380545.html"> http://www.cnblogs.com/themost/p/6380545.html </a></td><td>摘要: 1 f = open('D:\\record.txt') 2 3 boy = [] 4 girl = [] 5 count=1 6 7 for each_line in f: 8 9 if each_line[:3] != '===': 10 (role, line_spoken) = each_line.split(':',1) 11 ...阅读全文</td></tr><tr align='center'><td>集合类型内建方法</td><td> <a href="http://www.cnblogs.com/themost/p/6376041.html"> http://www.cnblogs.com/themost/p/6376041.html </a></td><td></td></tr><tr align='center'><td>集合</td><td> <a href="http://www.cnblogs.com/themost/p/6375966.html"> http://www.cnblogs.com/themost/p/6375966.html </a></td><td>摘要: 在python中集合就是唯一，表示集合中的元素都是唯一的，不存在重复。 1、创建集合的方法： 一、直接用花括号 >>> num1={1,2,3,3,3}>>> num1{1, 2, 3} 二、用工厂函数set >>> num2=[1,2,1,2,3,4,5,2]>>> num2=set(num2)>阅读全文</td></tr><tr align='center'><td>用户登录系统</td><td> <a href="http://www.cnblogs.com/themost/p/6375889.html"> http://www.cnblogs.com/themost/p/6375889.html </a></td><td>摘要: #用户登陆系统 print('|---新建用户：N/n---|') print('|---登陆账号：E/e--|') print('|---退出程序：Q/q---|') guest=dict() while True: print('|---请输入指令代码：',end='') enter = input() if enter == 'N' or enter == 'n'...阅读全文</td></tr><tr align='center'><td>fromkeys() keys() values()  items()</td><td> <a href="http://www.cnblogs.com/themost/p/6371993.html"> http://www.cnblogs.com/themost/p/6371993.html </a></td><td>摘要: 1 fromkeys() 2 3 >>> dict1={} 4 >>> dict1.fromkeys((1,2,3))#会自动为没有赋值的值建立none 5 {1: None, 2: None, 3: None} 6 >>> dict1.fromkeys((1,2,3),'number')＃将前一个括号分别与后面结合成项 7 {1: 'number', 2: 'number', ...阅读全文</td></tr><tr align='center'><td>通讯录程序</td><td> <a href="http://www.cnblogs.com/themost/p/6371892.html"> http://www.cnblogs.com/themost/p/6371892.html </a></td><td>摘要: #通讯录程序 print('|---欢迎进入通讯录程序---|') print('|---1:查询联系人资料---|') print('|---2:插入新的联系人---|') print('|---3:删除已有联系人---|') print('|---4:退出通讯录程序---|') address=dict() while True: print('请输入相关指令代码:',end=''...阅读全文</td></tr><tr align='center'><td>字符串分割方法split()函数</td><td> <a href="http://www.cnblogs.com/themost/p/6368352.html"> http://www.cnblogs.com/themost/p/6368352.html </a></td><td>摘要: >>> data = '1000,小甲鱼,男'>>> data.split(',')['1000', '小甲鱼', '男'] str.split('以什么为标志进行分割'，'分割次数')阅读全文</td></tr><tr align='center'><td>装逼的本质就是把同一东西说成不同的事物</td><td> <a href="http://www.cnblogs.com/themost/p/6368331.html"> http://www.cnblogs.com/themost/p/6368331.html </a></td><td>摘要: 比如：字典，可以说成 映射，哈希，散列，或者关系数组阅读全文</td></tr><tr align='center'><td>字典</td><td> <a href="http://www.cnblogs.com/themost/p/6367777.html"> http://www.cnblogs.com/themost/p/6367777.html </a></td><td>摘要: 列表：中括号 元组：小括号与逗号 列表、元组、字符串是序列类型 字典：大括号 键key 值value 组合 字典是映射类型 >>> brand=['李宁','耐克','阿迪达斯','鱼C工作室']>>> slogan=['一切皆有可能','Just do it','Impossible is not阅读全文</td></tr><tr align='center'><td>递归求解汉诺塔</td><td> <a href="http://www.cnblogs.com/themost/p/6360459.html"> http://www.cnblogs.com/themost/p/6360459.html </a></td><td>摘要: #递归求解汉诺塔 def hanoi(n,x,y,z): if n == 1: print(x,'-->',z) else: #将n-1个盘子从x借助z移动到y上 hanoi(n-1,x,z,y) #将最后一个盘子从x移动到z上 print(x,'-->',z) #将n-1个盘子从y借...阅读全文</td></tr><tr align='center'><td>斐波那契数列 迭代与递归效率对比</td><td> <a href="http://www.cnblogs.com/themost/p/6360320.html"> http://www.cnblogs.com/themost/p/6360320.html </a></td><td>摘要: 迭代法： 递归法：阅读全文</td></tr><tr align='center'><td>欧几里得算法</td><td> <a href="http://www.cnblogs.com/themost/p/6360189.html"> http://www.cnblogs.com/themost/p/6360189.html </a></td><td>摘要: #欧几里得算法 def myfun(x,y): if x % y == 0: return y else: temp = y y = x % y x = temp return myfun(x,y) num1 = int(input("请输入x：")) num2 = int(input("请输入y：...阅读全文</td></tr><tr align='center'><td>递归</td><td> <a href="http://www.cnblogs.com/themost/p/6360132.html"> http://www.cnblogs.com/themost/p/6360132.html </a></td><td>摘要: 1 #递归即函数自己调用自己 2 def factorial(n): 3 if n == 1: 4 return n 5 else: 6 return n * factorial(n-1) 7 8 number=int(input('请输入一个正整数> ')) 9 result = factorial(number) 10 pr...阅读全文</td></tr><tr align='center'><td>字符长串破解密码</td><td> <a href="http://www.cnblogs.com/themost/p/6359631.html"> http://www.cnblogs.com/themost/p/6359631.html </a></td><td>摘要: a)每个密码为单个小写字母 b）每个密码左右两边均有且只有三个大写字母 ＃方法一： ＃方法二：阅读全文</td></tr><tr align='center'><td>对return函数的认识</td><td> <a href="http://www.cnblogs.com/themost/p/6359175.html"> http://www.cnblogs.com/themost/p/6359175.html </a></td><td>摘要: 例1: def funOut(): def funIn(): print('宾果！你成功访问到我啦！') return funIn() ＃注意这里return的是funIn（）即是一个函数 funOut() 宾果！你成功访问到我啦！ 这里如何调用funIn，要记得return其实是个函数，他会在函数阅读全文</td></tr><tr align='center'><td>global与nonlocal关键字总结</td><td> <a href="http://www.cnblogs.com/themost/p/6359149.html"> http://www.cnblogs.com/themost/p/6359149.html </a></td><td>摘要: global适用于函数内部修改全局变量的值 nonlocal适用于嵌套函数中内部函数修改外部变量的值 如果没有使用以上关键字，对全局变量或者外部变量进行修改，python会默认将全局变量隐藏起来 例1: def outside(): var = 5 def inside(): var = 3 pri阅读全文</td></tr><tr align='center'><td>闭包</td><td> <a href="http://www.cnblogs.com/themost/p/6359114.html"> http://www.cnblogs.com/themost/p/6359114.html </a></td><td>摘要: 闭包：函数式编程重要的语法结构 如果在一个内部函数里，对外部作用域（但不是全局变量）的变量进行引用，那么内部函数就被称为闭包，举例如下 >>> def funX(x): def funY(y): return x * y ＃这里的内部函数funY对外部作用的变量x进行了引用，就成内部函数funY为闭阅读全文</td></tr><tr align='center'><td>内嵌函数</td><td> <a href="http://www.cnblogs.com/themost/p/6358944.html"> http://www.cnblogs.com/themost/p/6358944.html </a></td><td>摘要: 函数的内嵌即在函数内部定义函数，在内部定义的函数所有的一切都在函数内部，外部无法调用，举例如下： >>> def fun1(): print("fun1()正在被调用。。。") def fun2(): print("fun2()正在被调用。。。") fun2() >>> fun1()fun1()正在阅读全文</td></tr><tr align='center'><td>global关键字修改全局变量</td><td> <a href="http://www.cnblogs.com/themost/p/6358928.html"> http://www.cnblogs.com/themost/p/6358928.html </a></td><td>摘要: ＃我们知道全局变量在函数外部，强烈建议不要在函数内部修改全局变量，正常情况下，在函数内部改变全局变量并不影响全局变量的值，举例如下 count ＝ 5 >>> def myfun(): count = 10 ＃在函数内部修改了count print(count) >>> myfun() ＃调用myf阅读全文</td></tr><tr align='center'><td>[python] sys模块</td><td> <a href="http://www.cnblogs.com/themost/p/6358913.html"> http://www.cnblogs.com/themost/p/6358913.html </a></td><td>摘要: sys.argv 命令行参数List，第一个元素是程序本身路径 sys.modules.keys() 返回所有已经导入的模块列表 sys.exc_info() 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息 sys.exit(n) 退阅读全文</td></tr><tr align='center'><td>read运行</td><td> <a href="http://www.cnblogs.com/themost/p/6358911.html"> http://www.cnblogs.com/themost/p/6358911.html </a></td><td>摘要: #_*_ coding:utf-8 _*_ from sys import argv from os.path import exists script, from_file, to_file = argv print "copying from %s to %s" % (from_file, to阅读全文</td></tr><tr align='center'><td>Python open()函数文件打开、读、写操作详解</td><td> <a href="http://www.cnblogs.com/themost/p/6358910.html"> http://www.cnblogs.com/themost/p/6358910.html </a></td><td>摘要: 一、Python open()函数文件打开操作 打开文件会用到open函数，标准的python打开文件语法如下：open(name[,mode[,buffering]])open函数的文件名是必须的，而模式和缓冲参数都是可选的。比如说有个a.txt的文本文件，存放在c:\text下，那么你要打开它可阅读全文</td></tr><tr align='center'><td>from sys import argv</td><td> <a href="http://www.cnblogs.com/themost/p/6358907.html"> http://www.cnblogs.com/themost/p/6358907.html </a></td><td>摘要: from sys import argv 初学理解： sys 为内置模块，提供了许多函数和变量来处理 Python 运行时环境的不同部分。是固定的用法，不能自己随便写名字代替它，这行的作用就是要把用到的东西（比如需要什么特定函数什么之类的）从这个东西存放的模块中引入程序中。 就好比C语言中的strl阅读全文</td></tr><tr align='center'><td>raw_input() 与 input()</td><td> <a href="http://www.cnblogs.com/themost/p/6358906.html"> http://www.cnblogs.com/themost/p/6358906.html </a></td><td>摘要: raw_input() 与 input() __ Python 这两个均是 python 的内建函数，通过读取控制台的输入与用户实现交互。但他们的功能不尽相同。举两个小例子。 1 >>> raw_input_A = raw_input("raw_input: ") 2 raw_input: abc 阅读全文</td></tr><tr align='center'><td>IndentationError : expected an indented block</td><td> <a href="http://www.cnblogs.com/themost/p/6358903.html"> http://www.cnblogs.com/themost/p/6358903.html </a></td><td>摘要: IndentationError:在python的条件语句出现 expected an indented block问题 是指缩进问题，比如for循环里面的print前面需要四个空格。 Python语言是一款对缩进非常敏感的语言，给很多初学者带来了困惑，即便是很有经验的Python程序员，也可能陷入阅读全文</td></tr><tr align='center'><td>round()函数 浮点数的四舍五入</td><td> <a href="http://www.cnblogs.com/themost/p/6358901.html"> http://www.cnblogs.com/themost/p/6358901.html </a></td><td>摘要: 浮点数的四舍五入 print round(1.7333) 2.0阅读全文</td></tr><tr align='center'><td>编码注释coding: utf-8</td><td> <a href="http://www.cnblogs.com/themost/p/6358900.html"> http://www.cnblogs.com/themost/p/6358900.html </a></td><td>摘要: # -*- coding: utf-8 -*- PY文件当中是不支持中文的，即使你输入的注释是中文也不行，为了解决这个问题，就需要把文件编码类型改为UTF-8的类型，输入这个代码就可以让PY源文件里面有中文了。建议写代码之前都把这句话加上，因为不管是注释还是弹出消息提示，免不了的要输入中文，所以这个阅读全文</td></tr><tr align='center'><td>lambda表达式</td><td> <a href="http://www.cnblogs.com/themost/p/6358898.html"> http://www.cnblogs.com/themost/p/6358898.html </a></td><td>摘要: lambda表达式，冒号前面的是参数，后面的是返回值。 Python写一些执行脚本时，使用lambda就可以省下定义函数过程，比如说我们只是需要写个简单的脚本来管理服务器时间，我们就不需要专门定义一个函数然后再写调用，使用lambda就可以使得代码更加精简。 对于一些比较抽象并且整个程序执行下来只需阅读全文</td></tr><tr align='center'><td>filter过滤器与map映射</td><td> <a href="http://www.cnblogs.com/themost/p/6358899.html"> http://www.cnblogs.com/themost/p/6358899.html </a></td><td>摘要: filter过滤器 >>> list(filter(None,[0,1,2,True,False])) [1, 2, True] filter的作用就是后面的数据按照前面的表达式运算后，得出为False则去掉，返回所有为True的值。 ＃举例找出0—100所有的奇数 def myfun(x): re阅读全文</td></tr><tr align='center'><td>判断回文联</td><td> <a href="http://www.cnblogs.com/themost/p/6358897.html"> http://www.cnblogs.com/themost/p/6358897.html </a></td><td>摘要: #判断回文联 上海自来水来自海上 def judgesentence(sentence): lenth=len(sentence) for each in range(lenth): if sentence[each]==sentence[-(each+1)]: q=True else: q=Fal阅读全文</td></tr><tr align='center'><td>python自定义函数可以向前引用不用声明</td><td> <a href="http://www.cnblogs.com/themost/p/6358896.html"> http://www.cnblogs.com/themost/p/6358896.html </a></td><td>摘要: #有些编程语言不够“聪明”，向这类向前引用的方式会导致报错，但Python足够“醒目”，这段代码是正确的！ def next(): print('我在next()函数里...') pre() def pre(): print('我在pre()函数里...') next() 我在next()函数里..阅读全文</td></tr><tr align='center'><td>所有参数的和乘以基数</td><td> <a href="http://www.cnblogs.com/themost/p/6358893.html"> http://www.cnblogs.com/themost/p/6358893.html </a></td><td>摘要: a) 计算打印所有参数的和乘以基数（base=3）的结果 b) 如果参数中最后一个参数为（base=5），则设定基数为5，基数不参与求和计算。 def myfun(*num): rs=0 for i in num: rs=rs+i if num[-1]==5: re=(rs-5)*5 else: r阅读全文</td></tr><tr align='center'><td>子字符串在目标字符串中出现的次数</td><td> <a href="http://www.cnblogs.com/themost/p/6358894.html"> http://www.cnblogs.com/themost/p/6358894.html </a></td><td>摘要: 编写一个函数 findstr()，该函数统计一个长度为 2 的子字符串在另一个字符串中出现的次数。例如：假定输入的字符串为“You cannot improve your past, but you can improve your future. Once time is wasted, life阅读全文</td></tr><tr align='center'><td>除二取余倒序排列</td><td> <a href="http://www.cnblogs.com/themost/p/6358892.html"> http://www.cnblogs.com/themost/p/6358892.html </a></td><td>摘要: def Dec2Bin(dec): temp = [] result = '' while dec: quo = dec % 2 dec = dec // 2 temp.append(quo) while temp: result += str(temp.pop()) ...阅读全文</td></tr><tr align='center'><td>转换进制程序</td><td> <a href="http://www.cnblogs.com/themost/p/6358891.html"> http://www.cnblogs.com/themost/p/6358891.html </a></td><td>摘要: #转换进制程序 q=True while q: temp=input('您好，请输入一个整数:''(输入q退出程序)''\n') if temp!='q': num=int(temp) print('十进制到十六进制：%d>>0x%x' % (num,num)) print('十进制到八进制：%d>阅读全文</td></tr><tr align='center'><td>format的应用</td><td> <a href="http://www.cnblogs.com/themost/p/6358890.html"> http://www.cnblogs.com/themost/p/6358890.html </a></td><td>摘要: >>> "{a} love {b}.{c}".format(a="I", b="Fish", c="com") 'I love Fish.com' >>> '{0}{1:.2f}'.format('pi=',3.1415926) 'pi=3.14'阅读全文</td></tr><tr align='center'><td>字符串的格式化及转义字符</td><td> <a href="http://www.cnblogs.com/themost/p/6358889.html"> http://www.cnblogs.com/themost/p/6358889.html </a></td><td></td></tr><tr align='center'><td>两种方法思考密码安全性</td><td> <a href="http://www.cnblogs.com/themost/p/6358887.html"> http://www.cnblogs.com/themost/p/6358887.html </a></td><td>摘要: 方法一： #前置条件symbol='~!@#$%^&*()_=-/,.?<>;:[]{}\|'letter='abcdefghijklmnopqrstuvwxyz'nums='0123456789'#判断密码安全性的程序print('您好，请输入密码：')passwd=input()#首先判断一下用阅读全文</td></tr><tr align='center'><td>python的切片操作</td><td> <a href="http://www.cnblogs.com/themost/p/6358885.html"> http://www.cnblogs.com/themost/p/6358885.html </a></td><td>摘要: 切片操作符是序列名后跟一个方括号，方括号中有一对可选的数字，并用冒号分割。注意这与你使用的索引操作符十分相似。记住数是可选的，而冒号是必须的。 切片操作符中的第一个数（冒号之前）表示切片开始的位置，第二个数（冒号之后）表示切片到哪里结束，第三个数（冒号之后）表示切片间隔数。如果不指定第一个数，Pyt阅读全文</td></tr><tr align='center'><td>字符串的方法及注释</td><td> <a href="http://www.cnblogs.com/themost/p/6358883.html"> http://www.cnblogs.com/themost/p/6358883.html </a></td><td>摘要: ％r非常有用，他的含义是不管是整形还是字符串，都将打印出来阅读全文</td></tr><tr align='center'><td>列表&元组的内置方法</td><td> <a href="http://www.cnblogs.com/themost/p/6358882.html"> http://www.cnblogs.com/themost/p/6358882.html </a></td><td>摘要: 标红为元组可以使用阅读全文</td></tr><tr align='center'><td>元组tuple插入字符串的方式</td><td> <a href="http://www.cnblogs.com/themost/p/6358881.html"> http://www.cnblogs.com/themost/p/6358881.html </a></td><td>摘要: 元组无法更改，但是可以用切片的方式将头尾切出，中间‘+’字符串，后整体赋值原先的元组，举例如下 >>> temp=('东邪','西毒' ,'南帝') >>> temp=temp[:2]+('北丐',)+temp[2:]#元组切片用的很好 >>> temp ('东邪', '西毒', '北丐', '南帝阅读全文</td></tr><tr align='center'><td>列表推导式</td><td> <a href="http://www.cnblogs.com/themost/p/6358880.html"> http://www.cnblogs.com/themost/p/6358880.html </a></td><td>摘要: 1 #列表推导式是基于已有列表推算出新列表的方式 2 #方法一 3 list1=[(x,y) for x in range(10) for y in range(10) if x%2==0 if y%2!=0] 4 #方法二，推导过程 5 x,y=0,0 6 list=[(x,y)] 7 for x in range(10): 8 for y in range(10...阅读全文</td></tr><tr align='center'><td>python列表很聪明，支持负数索引</td><td> <a href="http://www.cnblogs.com/themost/p/6358878.html"> http://www.cnblogs.com/themost/p/6358878.html </a></td><td>摘要: python列表很聪明，支持负数索引阅读全文</td></tr><tr align='center'><td>append()/extend()/insert()/remove()/del/pop()/slice列表分片</td><td> <a href="http://www.cnblogs.com/themost/p/6358877.html"> http://www.cnblogs.com/themost/p/6358877.html </a></td><td>摘要: member = ['小甲鱼', 88, '黑夜', 90, '迷途', 85, '怡静', 90, '秋舞斜阳', 88] member.append('字符串')＃在列表结尾处增加字符串 member.extend(（'字符串1'）,('字符串2'))＃在列表结尾增加字符串1，2 member.阅读全文</td></tr><tr align='center'><td>三种方法打印列表（数组）</td><td> <a href="http://www.cnblogs.com/themost/p/6358876.html"> http://www.cnblogs.com/themost/p/6358876.html </a></td><td>摘要: #方法一 member = ['小甲鱼', 88, '黑夜', 90, '迷途', 85, '怡静', 90, '秋舞斜阳', 88] i=0 lenth=len(member) while i<lenth: print(member[i],member[i+1]) i+=2 #方法二 member阅读全文</td></tr><tr align='center'><td>三色球问题：红黄蓝各为3，3，6，取8个，求任意搭配</td><td> <a href="http://www.cnblogs.com/themost/p/6358873.html"> http://www.cnblogs.com/themost/p/6358873.html </a></td><td>摘要: #三色球问题：红黄蓝各为3，3，6，取8个，求任意搭配。 print('red', 'yellow', 'blue') for red in range(0,4): for yellow in range(0,4): for blue in range(0,7): if (red+yellow+bl阅读全文</td></tr><tr align='center'><td>求100-999之间所有的水仙花数</td><td> <a href="http://www.cnblogs.com/themost/p/6358872.html"> http://www.cnblogs.com/themost/p/6358872.html </a></td><td>摘要: #求100-999之间所有的水仙花数 例：153＝1^3+5^3+3^3 for num in range(100,1000): hundredp=int(num/100) tenp=int((num%100)/10) digitp=(num%100)%10 if num==(hundredp**3阅读全文</td></tr><tr align='center'><td>验证用户密码程序</td><td> <a href="http://www.cnblogs.com/themost/p/6358870.html"> http://www.cnblogs.com/themost/p/6358870.html </a></td><td>摘要: #验证用户密码程序，用户只有三次机会输入密码，如果三次输入错误程序退出，如果输入＊则不包含一次机会。 scode='wang' chance=3 print('您好，请输入密码，以回车键结束：') while chance: ecode=input('请输入密码：') if ecode==scode阅读全文</td></tr><tr align='center'><td>多次调用函数会降低效率</td><td> <a href="http://www.cnblogs.com/themost/p/6358780.html"> http://www.cnblogs.com/themost/p/6358780.html </a></td><td>摘要: ＃比较代码一 i=0 string='你好啊程序员' while i<len(string): print(i) i+=1 ＃比较代码二 i=0 string='你好啊程序员' lenth=len(string) while i<lenth: print(i) i+=1 i=0 string='你好阅读全文</td></tr><tr align='center'><td>for/range/break/continue</td><td> <a href="http://www.cnblogs.com/themost/p/6358779.html"> http://www.cnblogs.com/themost/p/6358779.html </a></td><td>摘要: #for智能循环 members=['武林至尊','宝刀屠龙','号令天下','莫敢不从'] for every in members: print(every,len(every)) 武林至尊 4 宝刀屠龙 4 号令天下 4 莫敢不从 4 武林至尊 4 宝刀屠龙 4 号令天下 4 莫敢不从 4 #阅读全文</td></tr><tr align='center'><td>in成员资格符</td><td> <a href="http://www.cnblogs.com/themost/p/6358778.html"> http://www.cnblogs.com/themost/p/6358778.html </a></td><td>摘要: #in成员资格符 name='小树' '小'in name# 返回True '大树'in name#返回False阅读全文</td></tr><tr align='center'><td>非常牛的实现三个数交换</td><td> <a href="http://www.cnblogs.com/themost/p/6358777.html"> http://www.cnblogs.com/themost/p/6358777.html </a></td><td>摘要: #非常牛的实现三个数交换 x,y,z=1,2,3 x,y,z=z,x,y print(x,y,z)阅读全文</td></tr><tr align='center'><td>assert后面如果是假则程序崩溃</td><td> <a href="http://www.cnblogs.com/themost/p/6358775.html"> http://www.cnblogs.com/themost/p/6358775.html </a></td><td>摘要: assert后面如果是假，则程序崩溃。阅读全文</td></tr><tr align='center'><td>python三元操作符</td><td> <a href="http://www.cnblogs.com/themost/p/6358773.html"> http://www.cnblogs.com/themost/p/6358773.html </a></td><td>摘要: #比较大小更简单了 x,y=3987,24361 small=(x if x<y else y) print(small) x,y=3987,24361 small=(x if x<y else y) print(small) #方法一：比较三个数的大小找出较大的一个 x,y,z=8,1,13 if阅读全文</td></tr><tr align='center'><td>三种方法划分成绩等级</td><td> <a href="http://www.cnblogs.com/themost/p/6358771.html"> http://www.cnblogs.com/themost/p/6358771.html </a></td><td>摘要: #三种方法划分成绩等级 #第一种： score=int(input("请输入成绩：")) if 90<=score<=100: print('A') if 80<=score<90: print('B') if 60<=score<80: print('C') if 0<=score<60: pri阅读全文</td></tr><tr align='center'><td>爱因斯坦难题</td><td> <a href="http://www.cnblogs.com/themost/p/6358770.html"> http://www.cnblogs.com/themost/p/6358770.html </a></td><td>摘要: 爱因斯坦曾经提出过这样一道有趣的数学题：有一个长阶梯，若每步上2阶，最后剩下1阶；若每步上3阶，最后剩2阶；若每步上5阶，最后剩下4阶；若每步上6阶，最后剩5阶；只有每步上7阶，最后刚好一阶也不剩。请问该阶梯至少有多少阶。 #爱因斯坦难题 num=0 while not((num%2==1)and(阅读全文</td></tr><tr align='center'><td>打印奇数</td><td> <a href="http://www.cnblogs.com/themost/p/6358768.html"> http://www.cnblogs.com/themost/p/6358768.html </a></td><td>摘要: #打印0-100所有的奇数oddnum=0while oddnum<1000: if oddnum%2!=0: print(oddnum) oddnum=oddnum+1阅读全文</td></tr><tr align='center'><td>判断给到的年份是否为闰年</td><td> <a href="http://www.cnblogs.com/themost/p/6358766.html"> http://www.cnblogs.com/themost/p/6358766.html </a></td><td>摘要: #写一个程序，判断给到的年份是否为闰年 temp=input('请输入一个年份：') while temp.isdigit()==False: temp=input('该吃药了吧，重新输入：') year=int(temp) if ((year%4==0) and (year%100!=0)) or阅读全文</td></tr><tr align='center'><td>猜谜小游戏</td><td> <a href="http://www.cnblogs.com/themost/p/6358763.html"> http://www.cnblogs.com/themost/p/6358763.html </a></td><td>摘要: #我们来写一个猜谜小游戏 respond=input('你好呀，咱们来一个心有灵犀的小游戏吧！y or n\n') if respond=='y': temp=input('好的！那我们开始，你猜一下我现在心中想的是那个数字,0-10之间的哦:\n') time=3 import random ta阅读全文</td></tr><tr align='center'><td>python小知识点</td><td> <a href="http://www.cnblogs.com/themost/p/6358762.html"> http://www.cnblogs.com/themost/p/6358762.html </a></td><td>摘要: 1、input()返回始终是字符串，得到整形需要改类型 2、用四舍五入的方式取整，每个整形数+0.5阅读全文</td></tr></table></body></html>